// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProjects = `-- name: CountProjects :one
SELECT COUNT(*) FROM projects
`

func (q *Queries) CountProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectsWithSearch = `-- name: CountProjectsWithSearch :one
SELECT COUNT(*) FROM projects WHERE ($1::text IS NULL OR $1::text = '' OR name ILIKE '%' || $1 || '%')
`

func (q *Queries) CountProjectsWithSearch(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectsWithSearch, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (status, name, category, client, "order", highlighted, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, status, name, category, client, "order", highlighted, created_at, updated_at
`

type CreateProjectParams struct {
	Status      int16       `json:"status"`
	Name        string      `json:"name"`
	Category    pgtype.Text `json:"category"`
	Client      pgtype.Text `json:"client"`
	Order       int32       `json:"order"`
	Highlighted bool        `json:"highlighted"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.Status,
		arg.Name,
		arg.Category,
		arg.Client,
		arg.Order,
		arg.Highlighted,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.Category,
		&i.Client,
		&i.Order,
		&i.Highlighted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, status, name, category, client, "order", highlighted, created_at, updated_at FROM projects WHERE id = $1
`

func (q *Queries) GetProjectByID(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.Category,
		&i.Client,
		&i.Order,
		&i.Highlighted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listHighlightedProjects = `-- name: ListHighlightedProjects :many
SELECT id, status, name, category, client, "order", highlighted, created_at, updated_at FROM projects WHERE highlighted = true ORDER BY "order" ASC, created_at DESC
`

func (q *Queries) ListHighlightedProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listHighlightedProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.Category,
			&i.Client,
			&i.Order,
			&i.Highlighted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT id, status, name, category, client, "order", highlighted, created_at, updated_at FROM projects ORDER BY "order" ASC, created_at DESC LIMIT $1 OFFSET $2
`

type ListProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProjects(ctx context.Context, arg ListProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.Category,
			&i.Client,
			&i.Order,
			&i.Highlighted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsWithSearch = `-- name: ListProjectsWithSearch :many
SELECT id, status, name, category, client, "order", highlighted, created_at, updated_at FROM projects 
WHERE ($1::text IS NULL OR $1::text = '' OR name ILIKE '%' || $1 || '%')
ORDER BY 
  CASE WHEN $2::text = 'order' AND $3::text = 'asc' THEN "order" ELSE NULL END ASC,
  CASE WHEN $2::text = 'order' AND $3::text = 'desc' THEN "order" ELSE NULL END DESC,
  CASE WHEN $2::text = 'name' AND $3::text = 'asc' THEN name ELSE NULL END ASC,
  CASE WHEN $2::text = 'name' AND $3::text = 'desc' THEN name ELSE NULL END DESC,
  CASE WHEN $2::text = 'created_at' AND $3::text = 'asc' THEN created_at ELSE NULL END ASC,
  CASE WHEN $2::text = 'created_at' AND $3::text = 'desc' THEN created_at ELSE NULL END DESC,
  CASE WHEN $2::text IS NULL OR $2::text = '' OR $2::text NOT IN ('order', 'name', 'created_at') THEN "order" ELSE NULL END ASC,
  created_at DESC
LIMIT $4 OFFSET $5
`

type ListProjectsWithSearchParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListProjectsWithSearch(ctx context.Context, arg ListProjectsWithSearchParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsWithSearch,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.Category,
			&i.Client,
			&i.Order,
			&i.Highlighted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicProjects = `-- name: ListPublicProjects :many
SELECT id, status, name, category, client, "order", highlighted, created_at, updated_at FROM projects ORDER BY "order" ASC, created_at DESC
`

func (q *Queries) ListPublicProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, listPublicProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.Category,
			&i.Client,
			&i.Order,
			&i.Highlighted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicProjectsPaginated = `-- name: ListPublicProjectsPaginated :many
SELECT id, status, name, category, client, "order", highlighted, created_at, updated_at FROM projects ORDER BY "order" ASC, created_at DESC LIMIT $1 OFFSET $2
`

type ListPublicProjectsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPublicProjectsPaginated(ctx context.Context, arg ListPublicProjectsPaginatedParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listPublicProjectsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.Category,
			&i.Client,
			&i.Order,
			&i.Highlighted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleProjectHighlight = `-- name: ToggleProjectHighlight :exec
UPDATE projects
SET highlighted = NOT highlighted,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ToggleProjectHighlight(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, toggleProjectHighlight, id)
	return err
}

const updateProject = `-- name: UpdateProject :exec
UPDATE projects
SET status = $2,
    name = $3,
    category = $4,
    client = $5,
    "order" = $6,
    highlighted = $7,
    updated_at = NOW()
WHERE id = $1
`

type UpdateProjectParams struct {
	ID          int64       `json:"id"`
	Status      int16       `json:"status"`
	Name        string      `json:"name"`
	Category    pgtype.Text `json:"category"`
	Client      pgtype.Text `json:"client"`
	Order       int32       `json:"order"`
	Highlighted bool        `json:"highlighted"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.db.Exec(ctx, updateProject,
		arg.ID,
		arg.Status,
		arg.Name,
		arg.Category,
		arg.Client,
		arg.Order,
		arg.Highlighted,
	)
	return err
}
